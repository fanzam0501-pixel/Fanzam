<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰”çº¸é£æœº âœˆï¸</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #90EE90 50%, #7CFC00 100%);
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #333;
            font-size: 18px;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
            pointer-events: none;
        }
        
        #ui h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        #ui .stats {
            background: rgba(255,255,255,0.8);
            padding: 10px 15px;
            border-radius: 10px;
            display: inline-block;
        }
        
        #ui .stats div {
            margin: 5px 0;
        }
        
        .label {
            color: #666;
            font-size: 14px;
        }
        
        .value {
            color: #2196F3;
            font-weight: bold;
            font-size: 20px;
        }
        
        #windIndicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #windArrow {
            font-size: 30px;
            transition: transform 0.3s ease;
        }
        
        #instructions {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 16px;
            text-align: center;
        }
        
        .cloud {
            position: absolute;
            background: white;
            border-radius: 100px;
            opacity: 0.8;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h1>âœˆï¸ çº¸é£æœºå¤§ä½œæˆ˜</h1>
        <div class="stats">
            <div><span class="label">æœ€è¿œè·ç¦»</span><br><span class="value" id="bestDistance">0m</span></div>
            <div><span class="label">æœ¬æ¬¡é£è¡Œ</span><br><span class="value" id="currentDistance">0m</span></div>
            <div><span class="label">é£è¡Œæ¬¡æ•°</span><br><span class="value" id="throwCount">0</span></div>
        </div>
    </div>
    
    <div id="windIndicator">
        <span id="windArrow">ğŸ’¨</span>
    </div>
    
    <div id="instructions">ğŸ–±ï¸ æ‹–æ‹½çº¸é£æœºå‘å°„ | é£å¾—è¶Šè¿œè¶Šå¥½ï¼</div>
    
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // è®¾ç½®ç”»å¸ƒå¤§å°
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = 'aiming'; // aiming, flying, landed
        let bestDistance = parseInt(localStorage.getItem('paperPlaneBest')) || 0;
        let throwCount = 0;
        let currentDistance = 0;
        
        // é£åŠ›ç³»ç»Ÿ
        let windSpeed = (Math.random() - 0.5) * 0.3;
        let windDirection = windSpeed > 0 ? 1 : -1;
        
        // çº¸é£æœº
        const plane = {
            x: 100,
            y: canvas.height / 2,
            vx: 0,
            vy: 0,
            angle: 0,
            size: 30,
            trail: [],
            landed: false
        };
        
        // æ‹–æ‹½ç›¸å…³
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragCurrent = { x: 0, y: 0 };
        
        // åœ°é¢é«˜åº¦
        const groundHeight = canvas.height * 0.5;
        
        // äº‘æœµ
        const clouds = [];
        for (let i = 0; i < 5; i++) {
            clouds.push({
                x: Math.random() * canvas.width,
                y: Math.random() * groundHeight * 0.6,
                size: 40 + Math.random() * 60,
                speed: 0.2 + Math.random() * 0.3
            });
        }
        
        // è·ç¦»æ ‡è®°
        const markers = [];
        for (let i = 0; i <= 2000; i += 100) {
            markers.push({ distance: i, x: 100 + i * 2 });
        }
        
        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('bestDistance').textContent = Math.floor(bestDistance) + 'm';
            document.getElementById('currentDistance').textContent = Math.floor(currentDistance) + 'm';
            document.getElementById('throwCount').textContent = throwCount;
            
            // æ›´æ–°é£å‘æŒ‡ç¤º
            const arrow = document.getElementById('windArrow');
            const rotation = windSpeed * 200;
            arrow.style.transform = `rotate(${rotation}deg)`;
        }
        
        // ç»˜åˆ¶çº¸é£æœº
        function drawPlane(x, y, angle, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.scale(size / 30, size / 30);
            
            // é£æœºä¸»ä½“
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            
            ctx.beginPath();
            ctx.moveTo(25, 0);
            ctx.lineTo(-15, -12);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-15, 12);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // æŠ˜ç—•
            ctx.beginPath();
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, -8);
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, 8);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶äº‘æœµ
        function drawCloud(cloud) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(cloud.x, cloud.y, cloud.size * 0.5, 0, Math.PI * 2);
            ctx.arc(cloud.x + cloud.size * 0.3, cloud.y - cloud.size * 0.2, cloud.size * 0.4, 0, Math.PI * 2);
            ctx.arc(cloud.x + cloud.size * 0.5, cloud.y, cloud.size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ç»˜åˆ¶åœºæ™¯
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç›¸æœºåç§»
            let cameraX = 0;
            if (gameState === 'flying' || gameState === 'landed') {
                cameraX = plane.x - 200;
                cameraX = Math.max(0, cameraX);
            }
            
            ctx.save();
            ctx.translate(-cameraX, 0);
            
            // ç»˜åˆ¶äº‘æœµ
            clouds.forEach(cloud => {
                drawCloud(cloud);
            });
            
            // ç»˜åˆ¶åœ°é¢
            const gradient = ctx.createLinearGradient(0, groundHeight, 0, canvas.height);
            gradient.addColorStop(0, '#90EE90');
            gradient.addColorStop(1, '#228B22');
            ctx.fillStyle = gradient;
            ctx.fillRect(cameraX, groundHeight, canvas.width, canvas.height - groundHeight);
            
            // ç»˜åˆ¶è‰åœ°çº¹ç†
            ctx.strokeStyle = '#1a6b1a';
            ctx.lineWidth = 2;
            for (let i = cameraX; i < cameraX + canvas.width; i += 20) {
                const grassHeight = 5 + Math.sin(i * 0.1) * 3;
                ctx.beginPath();
                ctx.moveTo(i, groundHeight);
                ctx.lineTo(i + 3, groundHeight - grassHeight);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶è·ç¦»æ ‡è®°
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            markers.forEach(marker => {
                if (marker.x >= cameraX - 50 && marker.x <= cameraX + canvas.width + 50) {
                    ctx.fillRect(marker.x, groundHeight - 15, 2, 15);
                    ctx.fillText(marker.distance + 'm', marker.x - 15, groundHeight + 20);
                }
            });
            
            // ç»˜åˆ¶è½¨è¿¹
            if (plane.trail.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(plane.trail[0].x, plane.trail[0].y);
                for (let i = 1; i < plane.trail.length; i++) {
                    ctx.lineTo(plane.trail[i].x, plane.trail[i].y);
                }
                ctx.stroke();
            }
            
            // ç»˜åˆ¶å‘å°„çº¿
            if (isDragging) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(plane.x, plane.y);
                ctx.lineTo(dragCurrent.x + cameraX, dragCurrent.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ç»˜åˆ¶åŠ›é‡æŒ‡ç¤º
                const dx = plane.x - (dragCurrent.x + cameraX);
                const dy = plane.y - dragCurrent.y;
                const power = Math.sqrt(dx * dx + dy * dy);
                const maxPower = 200;
                const powerPercent = Math.min(power / maxPower, 1);
                
                ctx.fillStyle = `hsl(${120 - powerPercent * 120}, 100%, 50%)`;
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText(`åŠ›åº¦: ${Math.floor(powerPercent * 100)}%`, plane.x + 35, plane.y - 20);
            }
            
            // ç»˜åˆ¶çº¸é£æœº
            drawPlane(plane.x, plane.y, plane.angle, plane.size);
            
            // ç»˜åˆ¶è½ç‚¹æ ‡è®°
            if (gameState === 'landed') {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(plane.x, groundHeight, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // è·ç¦»æ–‡å­—
                ctx.fillStyle = '#333';
                ctx.font = 'bold 20px sans-serif';
                ctx.fillText(`${Math.floor(currentDistance)}m`, plane.x - 25, groundHeight - 20);
            }
            
            ctx.restore();
        }
        
        // æ›´æ–°æ¸¸æˆé€»è¾‘
        function update() {
            // æ›´æ–°äº‘æœµ
            clouds.forEach(cloud => {
                cloud.x += cloud.speed + windSpeed * 2;
                if (cloud.x > canvas.width + 100) {
                    cloud.x = -100;
                }
            });
            
            if (gameState === 'flying') {
                // ç‰©ç†æ›´æ–°
                plane.x += plane.vx;
                plane.y += plane.vy;
                
                // é‡åŠ›
                plane.vy += 0.15;
                
                // ç©ºæ°”é˜»åŠ›
                plane.vx *= 0.995;
                plane.vy *= 0.995;
                
                // é£åŠ›å½±å“
                plane.vx += windSpeed * 0.1;
                
                // è®¡ç®—è§’åº¦
                plane.angle = Math.atan2(plane.vy, plane.vx);
                
                // æ·»åŠ è½¨è¿¹ç‚¹
                if (plane.trail.length === 0 || 
                    Math.hypot(plane.x - plane.trail[plane.trail.length-1].x, 
                              plane.y - plane.trail[plane.trail.length-1].y) > 10) {
                    plane.trail.push({ x: plane.x, y: plane.y });
                }
                
                // æ£€æŸ¥æ˜¯å¦è½åœ°
                if (plane.y >= groundHeight) {
                    plane.y = groundHeight;
                    plane.landed = true;
                    gameState = 'landed';
                    
                    // è®¡ç®—è·ç¦»
                    currentDistance = Math.max(0, (plane.x - 100) / 2);
                    if (currentDistance > bestDistance) {
                        bestDistance = currentDistance;
                        localStorage.setItem('paperPlaneBest', bestDistance);
                    }
                    
                    updateUI();
                    
                    // 3ç§’åå¯ä»¥å†æ¬¡å‘å°„
                    setTimeout(() => {
                        resetPlane();
                    }, 2000);
                }
                
                // é£å‡ºå±å¹•å¤ªè¿œ
                if (plane.y > canvas.height + 100 || plane.x < -100) {
                    resetPlane();
                }
            }
            
            updateUI();
        }
        
        // é‡ç½®é£æœº
        function resetPlane() {
            plane.x = 100;
            plane.y = canvas.height / 2;
            plane.vx = 0;
            plane.vy = 0;
            plane.angle = 0;
            plane.trail = [];
            plane.landed = false;
            gameState = 'aiming';
            
            // éšæœºæ”¹å˜é£åŠ›
            windSpeed = (Math.random() - 0.5) * 0.5;
            
            document.getElementById('instructions').textContent = 'ğŸ–±ï¸ æ‹–æ‹½çº¸é£æœºå‘å°„ | é£å¾—è¶Šè¿œè¶Šå¥½ï¼';
        }
        
        // æ¸¸æˆå¾ªç¯
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }
        
        // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶
        function getPos(e) {
            if (e.touches) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }
        
        function onStart(e) {
            if (gameState !== 'aiming') return;
            
            const pos = getPos(e);
            const dist = Math.hypot(pos.x - plane.x, pos.y - plane.y);
            
            if (dist < 60) {
                isDragging = true;
                dragStart = pos;
                dragCurrent = pos;
            }
        }
        
        function onMove(e) {
            if (!isDragging) return;
            dragCurrent = getPos(e);
        }
        
        function onEnd(e) {
            if (!isDragging) return;
            isDragging = false;
            
            // è®¡ç®—å‘å°„é€Ÿåº¦
            const dx = plane.x - dragCurrent.x;
            const dy = plane.y - dragCurrent.y;
            const power = Math.sqrt(dx * dx + dy * dy);
            
            if (power > 20) {
                const maxPower = 200;
                const scale = Math.min(power, maxPower) / 20;
                
                plane.vx = (dx / power) * scale * 8;
                plane.vy = (dy / power) * scale * 8;
                
                gameState = 'flying';
                throwCount++;
                
                document.getElementById('instructions').textContent = 'âœˆï¸ é£è¡Œä¸­...';
            }
        }
        
        // ç»‘å®šäº‹ä»¶
        canvas.addEventListener('mousedown', onStart);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onEnd);
        canvas.addEventListener('mouseleave', onEnd);
        
        canvas.addEventListener('touchstart', onStart, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMove(e); }, { passive: false });
        canvas.addEventListener('touchend', onEnd);
        
        // ç‚¹å‡»è½åœ°åå¿«é€Ÿé‡ç½®
        canvas.addEventListener('click', () => {
            if (gameState === 'landed') {
                resetPlane();
            }
        });
        
        // ç©ºæ ¼é”®å¿«é€Ÿé‡ç½®
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState === 'landed') {
                resetPlane();
            }
        });
        
        // å¯åŠ¨æ¸¸æˆ
        updateUI();
        loop();
    </script>
</body>
</html>
